//Brute force 
approach 1- this approach consist of a map so while traversing the linkedlistone we insert node and its value into the map 
and then while traversing the second linked list if  we find the value we return it immediately else we keep iterating we 
the condition is never true then return the NULL

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        unordered_map<ListNode*,int>mp;
        ListNode* curr=headA;
        while(curr!=NULL)
        {
            mp.insert({curr,curr->val});
            curr=curr->next;
        }
        ListNode* scurr=headB;
        while(scurr!=NULL)
        {
            if(mp.find(scurr)!=mp.end())
            {
                return scurr;
            }
            scurr=scurr->next;
        }
        return NULL;
    }
};

//optimal approach :->
A base case is if any of the two linekdlist is null we can directly return the NULL;
we take 2 temprary variable to traverse through the linkedlist and we keep traverse while traversing if they intersect we can retur
temp1 or if any of the list reaches the end we directly point it to a diffrent list head Same with list 2 
at the end if condition fails then we return temp1;

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
        if (headA == NULL || headB == NULL)
            return NULL;

        ListNode* temp1 = headA;
        ListNode* temp2 = headB;

        while (temp1 != temp2) {
            temp1 = temp1->next;
            temp2 = temp2->next;

            if (temp1 == temp2)
                return temp1;
            if (temp1 == NULL)
                temp1 = headB;
            if (temp2 == NULL)
                temp2 = headA;
        }
        return temp1;
    }
};
